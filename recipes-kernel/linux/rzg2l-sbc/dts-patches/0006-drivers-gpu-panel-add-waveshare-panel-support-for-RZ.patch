From 1b6721fd6d0b9bcd1839fa5191363d7fa49acb40 Mon Sep 17 00:00:00 2001
From: Tien Nguyen <tien.nguyen.uh@renesas.com>
Date: Tue, 17 Dec 2024 16:57:05 +0700
Subject: [PATCH 6/7] drivers: gpu: panel: add waveshare panel support for
 RZG2L SBC board

Added support for Waveshare 5 inch Touchscreen Monitor MIPI-DSI LCD on
the RZG2L SBC board.

Upstream-Status: Pending

Signed-off-by: Long Trinh <long.trinh.rh@bp.renesas.com>
Signed-off-by: Tien Nguyen <tien.nguyen.uh@renesas.com>
---
 .../boot/dts/renesas/overlays/rzpi-dsi.dts    |   5 +-
 arch/arm64/boot/dts/renesas/rzpi.dts          |  17 +-
 drivers/gpu/drm/panel/Kconfig                 |  18 +
 drivers/gpu/drm/panel/Makefile                |   1 +
 .../gpu/drm/panel/panel-toshiba-tc358762.c    | 653 ++++++++++++++++++
 .../gpu/drm/panel/panel-toshiba-tc358762.h    |  18 +
 drivers/input/touchscreen/Kconfig             |  12 +
 drivers/input/touchscreen/Makefile            |   1 +
 drivers/input/touchscreen/rzsbc_ft5406.c      | 387 +++++++++++
 drivers/input/touchscreen/rzsbc_ft5406.h      |  66 ++
 drivers/misc/Kconfig                          |  16 +
 drivers/misc/Makefile                         |   1 +
 drivers/misc/rzsbc_mcu.c                      | 356 ++++++++++
 drivers/misc/rzsbc_mcu.h                      |  24 +
 14 files changed, 1569 insertions(+), 6 deletions(-)
 create mode 100644 drivers/gpu/drm/panel/panel-toshiba-tc358762.c
 create mode 100644 drivers/gpu/drm/panel/panel-toshiba-tc358762.h
 create mode 100644 drivers/input/touchscreen/rzsbc_ft5406.c
 create mode 100644 drivers/input/touchscreen/rzsbc_ft5406.h
 create mode 100644 drivers/misc/rzsbc_mcu.c
 create mode 100644 drivers/misc/rzsbc_mcu.h

diff --git a/arch/arm64/boot/dts/renesas/overlays/rzpi-dsi.dts b/arch/arm64/boot/dts/renesas/overlays/rzpi-dsi.dts
index b4ba27c1854e..536f842368bc 100644
--- a/arch/arm64/boot/dts/renesas/overlays/rzpi-dsi.dts
+++ b/arch/arm64/boot/dts/renesas/overlays/rzpi-dsi.dts
@@ -10,14 +10,15 @@ &dsi {
 	status = "okay";
 };
 
+// enable 5inch Waveshare panel (Raspberry Pi compatible)
 &mipi_panel {
 	status = "okay";
 };
 
-&gpt5 {
+&rzsbc_mcu {
 	status = "okay";
 };
 
-&backlight {
+&rzsbc_ft5406 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/renesas/rzpi.dts b/arch/arm64/boot/dts/renesas/rzpi.dts
index c6c5d7fedeea..97b5a7e1ffa2 100644
--- a/arch/arm64/boot/dts/renesas/rzpi.dts
+++ b/arch/arm64/boot/dts/renesas/rzpi.dts
@@ -664,6 +664,18 @@ sii9022_out: endpoint {
 			};
 		};
 	};
+
+	rzsbc_mcu: rzsbc_mcu@45 {
+		compatible = "rzsbc_mcu";
+		reg = <0x45>;
+		status = "disabled";
+	};
+
+	rzsbc_ft5406: rzsbc_ft5406@38 {
+		compatible = "rzsbc_ft5406";
+		reg = <0x38>;
+		status = "disabled";
+	};
 };
 
 &mtu3 {
@@ -854,11 +866,8 @@ dsi0_out: endpoint {
 	};
 
 	mipi_panel: panel@0 {
-		compatible = "ilitek,ph720128t003";
+		compatible = "rzsbc,tc358762";
 		reg = <0>;
-		power-gpios = <&pinctrl RZG2L_GPIO(4, 1) GPIO_ACTIVE_HIGH>;
-		switch-gpios = <&pinctrl RZG2L_GPIO(4, 0) GPIO_ACTIVE_HIGH>;
-		backlight = <&backlight>;
 		status = "disabled";
 
 		port {
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 2ae0eb0638f3..24138845a659 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -902,6 +902,24 @@ config DRM_PANEL_TRULY_NT35597_WQXGA
 	  Say Y here if you want to enable support for Truly NT35597 WQXGA Dual DSI
 	  Video Mode panel
 
+config DRM_PANEL_TOSHIBA_TC358762
+    tristate "Support for Toshiba TC358762"
+    depends on OF && I2C
+    depends on BACKLIGHT_CLASS_DEVICE
+    select VIDEOMODE_HELPERS
+    help
+      Enable support for the Toshiba TC358762 display bridge. This bridge is used
+      to interface with displays using the Toshiba TC358762 chip. The driver
+      allows for proper communication with the chip over I2C and configures the
+      panel for use on compatible systems.
+
+      If you say 'Y' here, the driver will be built into the kernel. If you say 'M',
+      it will be built as a module. The module can then be loaded and unloaded as needed.
+
+      To use this driver, you need a system with the Toshiba TC358762 bridge and
+      the necessary I2C and backlight support.
+
+
 config DRM_PANEL_VISIONOX_R66451
 	tristate "Visionox R66451"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index f0203f6e02f4..8c99da612810 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -91,6 +91,7 @@ obj-$(CONFIG_DRM_PANEL_TPO_TD028TTEC1) += panel-tpo-td028ttec1.o
 obj-$(CONFIG_DRM_PANEL_TPO_TD043MTEA1) += panel-tpo-td043mtea1.o
 obj-$(CONFIG_DRM_PANEL_TPO_TPG110) += panel-tpo-tpg110.o
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
+obj-$(CONFIG_DRM_PANEL_TOSHIBA_TC358762) += panel-toshiba-tc358762.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_VTDR6130) += panel-visionox-vtdr6130.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_R66451) += panel-visionox-r66451.o
diff --git a/drivers/gpu/drm/panel/panel-toshiba-tc358762.c b/drivers/gpu/drm/panel/panel-toshiba-tc358762.c
new file mode 100644
index 000000000000..7be7c3a2c2db
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-toshiba-tc358762.c
@@ -0,0 +1,653 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Renesas Electronics Corporation.
+ * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/backlight.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_edid.h>
+
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+
+#include "panel-toshiba-tc358762.h"
+
+int trigger_bridge = 1;
+
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+
+	unsigned int bpc;
+
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	/**
+	 * @prepare: the time (in milliseconds) that it takes for the panel to
+	 *		become ready and start receiving video data
+	 * @enable: the time (in milliseconds) that it takes for the panel to
+	 *		display the first valid frame after starting to receive
+	 *		video data
+	 * @disable: the time (in milliseconds) that it takes for the panel to
+	 *		turn the display off (no content is visible)
+	 * @unprepare: the time (in milliseconds) that it takes for the panel
+	 *		to power itself down completely
+	 */
+	struct {
+		unsigned int prepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int unprepare;
+	} delay;
+
+	u32 bus_format;
+};
+
+struct tc358762 {
+	struct drm_panel base;
+	struct drm_connector *connector;
+	struct drm_device *drm;
+	bool prepared;
+	bool enabled;
+
+	struct device *dev;
+	struct mipi_dsi_device *dsi;
+	const struct panel_desc *desc;
+
+	struct backlight_device *backlight;
+	struct regulator *supply;
+	struct i2c_adapter *ddc;
+
+	struct gpio_desc *enable_gpio;
+};
+
+static inline struct tc358762 *to_tc358762(struct drm_panel *panel)
+{
+	return container_of(panel, struct tc358762, base);
+}
+
+static int tc358762_get_fixed_modes(struct tc358762 *panel)
+{
+	struct drm_connector *connector = panel->connector;
+	struct drm_device *drm = panel->drm;
+	struct drm_display_mode *mode;
+	unsigned int i, num = 0;
+
+	if (!panel->desc)
+		return 0;
+
+	for (i = 0; i < panel->desc->num_timings; i++) {
+		const struct display_timing *dt = &panel->desc->timings[i];
+		struct videomode vm;
+
+		videomode_from_timing(dt, &vm);
+		mode = drm_mode_create(drm);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u\n",
+				dt->hactive.typ, dt->vactive.typ);
+			continue;
+		}
+
+		drm_display_mode_from_videomode(&vm, mode);
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	for (i = 0; i < panel->desc->num_modes; i++) {
+		const struct drm_display_mode *m = &panel->desc->modes[i];
+
+		mode = drm_mode_duplicate(drm, m);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u\n",
+				m->hdisplay, m->vdisplay);
+			continue;
+		}
+
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	connector->display_info.bpc = panel->desc->bpc;
+	connector->display_info.width_mm = panel->desc->size.width;
+	connector->display_info.height_mm = panel->desc->size.height;
+	if (panel->desc->bus_format)
+		drm_display_info_set_bus_formats(&connector->display_info,
+						 &panel->desc->bus_format, 1);
+
+	return num;
+}
+
+static int tc358762_of_get_native_mode(struct tc358762 *panel)
+{
+	struct drm_connector *connector = panel->connector;
+	struct drm_device *drm = panel->drm;
+	struct drm_display_mode *mode;
+	struct device_node *timings_np;
+	int ret;
+	u32 bus_flags;
+
+	timings_np = of_get_child_by_name(panel->dev->of_node,
+					  "display-timings");
+	if (!timings_np) {
+		dev_dbg(panel->dev, "failed to find display-timings node\n");
+		return 0;
+	}
+
+	of_node_put(timings_np);
+	mode = drm_mode_create(drm);
+	if (!mode)
+		return 0;
+
+	ret = of_get_drm_display_mode(panel->dev->of_node, mode,
+					&bus_flags,
+					OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_dbg(panel->dev, "failed to find dts display timings\n");
+		drm_mode_destroy(drm, mode);
+		return 0;
+	}
+
+	drm_mode_set_name(mode);
+	mode->type |= DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static int tc358762_disable(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (!p->enabled)
+		return 0;
+
+	pr_info("panel disable\n");
+
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_POWERDOWN;
+		backlight_update_status(p->backlight);
+	} else {
+		pr_info("panel disable: no backlight device\n");
+		rzsbc_mcu_set_bright(0x00);
+	}
+
+	if (p->desc && p->desc->delay.disable)
+		msleep(p->desc->delay.disable);
+
+	rzsbc_mcu_screen_power_off();
+
+	p->enabled = false;
+
+	return 0;
+}
+
+static int tc358762_unprepare(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (!p->prepared)
+		return 0;
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 0);
+
+	regulator_disable(p->supply);
+
+	if (p->desc && p->desc->delay.unprepare)
+		msleep(p->desc->delay.unprepare);
+
+	p->prepared = false;
+
+	return 0;
+}
+
+static void tc358762_gen_write(struct mipi_dsi_device *dsi, const void *data, size_t len)
+{
+	int ret;
+
+	ret = mipi_dsi_generic_write(dsi, data, len);
+	if (ret < 0)
+		dev_err(&dsi->dev, "failed to writing gen seq\n");
+}
+
+#define tc358762_gen_write_seq(dsi, seq...) \
+({\
+	static const u8 d[] = { seq };\
+	tc358762_gen_write(dsi, d, ARRAY_SIZE(d));\
+})
+
+static int tc358762_dsi_init(struct tc358762 *p)
+{
+	struct mipi_dsi_device *dsi = p->dsi;
+
+	tc358762_gen_write_seq(dsi, 0x10, 0x02, 0x03, 0x00, 0x00, 0x00);//LANE
+	tc358762_gen_write_seq(dsi, 0x64, 0x01, 0x0c, 0x00, 0x00, 0x00);//D0S_CLRSIPOCOUNT
+	tc358762_gen_write_seq(dsi, 0x68, 0x01, 0x0c, 0x00, 0x00, 0x00);//D1S_CLRSIPOCOUNT
+	tc358762_gen_write_seq(dsi, 0x44, 0x01, 0x00, 0x00, 0x00, 0x00);//D0S_ATMR
+	tc358762_gen_write_seq(dsi, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00);//D1S_ATMR
+	tc358762_gen_write_seq(dsi, 0x14, 0x01, 0x15, 0x00, 0x00, 0x00);//LPTXTIMCNT
+	tc358762_gen_write_seq(dsi, 0x50, 0x04, 0x60, 0x00, 0x00, 0x00);//SPICMR/SPICTRL
+	tc358762_gen_write_seq(dsi, 0x20, 0x04, 0x52, 0x01, 0x10, 0x00);//PORT/LCDCTRL
+	tc358762_gen_write_seq(dsi, 0x24, 0x04, 0x14, 0x00, 0x1a, 0x00);//HBPR/HSR
+	tc358762_gen_write_seq(dsi, 0x28, 0x04, 0x20, 0x03, 0x69, 0x00);//HFPR/HDISP(*)
+	tc358762_gen_write_seq(dsi, 0x2c, 0x04, 0x02, 0x00, 0x15, 0x00);//VBFR/VSR
+	tc358762_gen_write_seq(dsi, 0x30, 0x04, 0xe0, 0x01, 0x07, 0x00);//VFPR/VDISP(*)
+	tc358762_gen_write_seq(dsi, 0x34, 0x04, 0x01, 0x00, 0x00, 0x00);//VFUEN
+	tc358762_gen_write_seq(dsi, 0x64, 0x04, 0x0f, 0x04, 0x00, 0x00);//SYSCTRL
+	tc358762_gen_write_seq(dsi, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00);//STARTPPI
+	tc358762_gen_write_seq(dsi, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00);//STARTDSI
+
+	usleep_range(10, 20);
+	return 0;
+}
+
+static int tc358762_prepare(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	int err;
+
+	if (p->prepared)
+		return 0;
+
+	err = regulator_enable(p->supply);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to enable supply: %d\n", err);
+		return err;
+	}
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 1);
+
+	if (p->desc && p->desc->delay.prepare)
+		msleep(p->desc->delay.prepare);
+
+	p->prepared = true;
+
+	return 0;
+}
+
+static int tc358762_enable(struct drm_panel *panel)
+{
+	struct tc358762 *p = to_tc358762(panel);
+
+	if (p->enabled)
+		return 0;
+
+	pr_info("panel enable\n");
+
+	if (trigger_bridge) {
+		pr_info("rzsbc_mcu_screen_power_up");
+		rzsbc_mcu_screen_power_up();
+
+		/* Some particulare rpi panel need powering on/off during suspend/resume */
+		/* to avoid the flicker about 7 seconds */
+		//trigger_bridge = 0;
+
+		msleep(100);
+		rzsbc_ft5406_start_polling();
+	}
+
+	tc358762_dsi_init(p);
+
+	if (p->desc && p->desc->delay.enable)
+		msleep(p->desc->delay.enable);
+
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(p->backlight);
+	} else {
+		pr_info("panel enable: no backlight device\n");
+		rzsbc_mcu_set_bright(0xFF);
+	}
+
+	p->enabled = true;
+
+	return 0;
+}
+
+static int tc358762_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	int num = 0;
+
+	p->connector = connector;
+
+	/* probe EDID if a DDC bus is available */
+	if (p->ddc) {
+		struct edid *edid = drm_get_edid(connector, p->ddc);
+
+		drm_connector_update_edid_property(connector, edid);
+		if (edid) {
+			num += drm_add_edid_modes(connector, edid);
+			kfree(edid);
+		}
+	}
+
+	/* add hard-coded panel modes */
+	num += tc358762_get_fixed_modes(p);
+
+	/* add device node plane modes */
+	num += tc358762_of_get_native_mode(p);
+
+	return num;
+}
+
+static int tc358762_get_timings(struct drm_panel *panel,
+					unsigned int num_timings,
+					struct display_timing *timings)
+{
+	struct tc358762 *p = to_tc358762(panel);
+	unsigned int i;
+
+	if (!p->desc)
+		return 0;
+
+	if (p->desc->num_timings < num_timings)
+		num_timings = p->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = p->desc->timings[i];
+
+	return p->desc->num_timings;
+}
+
+static const struct drm_panel_funcs tc358762_funcs = {
+	.disable = tc358762_disable,
+	.unprepare = tc358762_unprepare,
+	.prepare = tc358762_prepare,
+	.enable = tc358762_enable,
+	.get_modes = tc358762_get_modes,
+	.get_timings = tc358762_get_timings,
+};
+
+static int tc358762_mipi_probe(struct mipi_dsi_device *dsi, const struct panel_desc *desc)
+{
+	struct device_node *backlight, *ddc;
+	struct tc358762 *panel;
+	struct device *dev = &dsi->dev;
+	int err;
+
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	panel->enabled = false;
+	panel->prepared = false;
+	panel->desc = desc;
+	panel->dev = dev;
+	panel->dsi = dsi;
+
+	panel->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(panel->supply))
+		return PTR_ERR(panel->supply);
+
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(panel->enable_gpio)) {
+		err = PTR_ERR(panel->enable_gpio);
+		dev_err(dev, "failed to request GPIO: %d\n", err);
+		return err;
+	}
+
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+		panel->backlight = of_find_backlight_by_node(backlight);
+		of_node_put(backlight);
+
+		if (!panel->backlight)
+			return -EPROBE_DEFER;
+	} else {
+		panel->backlight =  rzsbc_mcu_get_backlightdev();
+		if (!panel->backlight) {
+			pr_info("%s get backlight fail\n", __func__);
+			//return -ENODEV;
+		} else {
+			panel->backlight->props.brightness = 255;
+			pr_info("%s get backligh device successful\n", __func__);
+		}
+	}
+
+	ddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);
+	if (ddc) {
+		panel->ddc = of_find_i2c_adapter_by_node(ddc);
+		of_node_put(ddc);
+
+		if (!panel->ddc) {
+			err = -EPROBE_DEFER;
+			goto free_backlight;
+		}
+	}
+
+	drm_panel_init(&panel->base, dev, &tc358762_funcs, DRM_MODE_CONNECTOR_DSI);
+	drm_panel_add(&panel->base);
+
+	if (err < 0)
+		goto free_ddc;
+
+	dev_set_drvdata(dev, panel);
+
+	return 0;
+
+free_ddc:
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+free_backlight:
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return err;
+}
+
+static int tc358762_remove(struct device *dev)
+{
+	struct tc358762 *panel = dev_get_drvdata(dev);
+
+	drm_panel_remove(&panel->base);
+
+	tc358762_disable(&panel->base);
+
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return 0;
+}
+
+static void tc358762_shutdown(struct device *dev)
+{
+	struct tc358762 *panel = dev_get_drvdata(dev);
+
+	tc358762_disable(&panel->base);
+}
+
+struct bridge_desc {
+	struct panel_desc desc;
+
+	unsigned long flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+};
+
+static const struct drm_display_mode tc358762_mode = {
+	.clock = 27448,
+	.hdisplay = 800,
+	.hsync_start = 800 + 70,
+	.hsync_end = 800 + 70 + 20,
+	.htotal = 800 + 70 + 20 + 26,
+	.vdisplay = 480,
+	.vsync_start = 480 + 7,
+	.vsync_end = 480 + 7 + 2,
+	.vtotal = 480 + 7 + 2 + 21,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct bridge_desc tc358762_bridge = {
+	.desc = {
+		.modes = &tc358762_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 217,
+			.height = 136,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO |
+		 MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 1,
+};
+
+static const struct of_device_id dsi_of_match[] = {
+	{
+		.compatible = "rzsbc,tc358762",
+		.data = &tc358762_bridge
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+int tc358762_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	const struct bridge_desc *desc;
+	const struct of_device_id *id;
+	const struct panel_desc *pdesc;
+	u32 val;
+	int err, timeout = 10;
+
+	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	while (!rzsbc_mcu_is_connected() && timeout > 0) {
+		msleep(50); // increase to probe if needed
+		timeout--;
+	}
+
+	desc = id->data;
+	desc = (struct bridge_desc *) dsi_of_match[0].data;
+
+	pr_info("find panel: %s\n", dsi_of_match[0].compatible);
+
+	if (desc) {
+		dsi->mode_flags = desc->flags;
+		dsi->format = desc->format;
+		dsi->lanes = desc->lanes;
+		pdesc = &desc->desc;
+	} else {
+		pdesc = NULL;
+	}
+	err = tc358762_mipi_probe(dsi, pdesc);
+
+	if (err < 0)
+		return err;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,flags", &val))
+		dsi->mode_flags = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,format", &val))
+		dsi->format = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,lanes", &val))
+		dsi->lanes = val;
+
+	return mipi_dsi_attach(dsi);
+}
+
+void tc358762_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	int err;
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
+
+	err = tc358762_remove(&dsi->dev);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to remove device from DSI host: %d\n", err);
+}
+
+void tc358762_dsi_shutdown(struct mipi_dsi_device *dsi)
+{
+	tc358762_shutdown(&dsi->dev);
+}
+
+static struct mipi_dsi_driver tc358762_dsi_driver = {
+	.driver = {
+		.name = "bridge-tc358762-dsi",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = tc358762_dsi_probe,
+	.remove = tc358762_dsi_remove,
+	.shutdown = tc358762_dsi_shutdown,
+};
+
+static int __init tc358762_init(void)
+{
+	int err;
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&tc358762_dsi_driver);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+module_init(tc358762_init);
+
+static void __exit tc358762_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&tc358762_dsi_driver);
+}
+module_exit(tc358762_exit);
+
+MODULE_AUTHOR("Vu Dang <vu.dang.te@renesas.com>");
+MODULE_AUTHOR("Jerry <xbl@rock-chips.com>");
+MODULE_DESCRIPTION("DRM Driver for RZSBC toshiba tc358762 Bridge");
+MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/panel/panel-toshiba-tc358762.h b/drivers/gpu/drm/panel/panel-toshiba-tc358762.h
new file mode 100644
index 000000000000..d555a380db15
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-toshiba-tc358762.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef PANEL_TOSHIBA_TC358762_H
+#define PANEL_TOSHIBA_TC358762_H
+
+#include <linux/backlight.h>
+
+extern struct backlight_device *rzsbc_mcu_get_backlightdev(void);
+extern int rzsbc_mcu_set_bright(int bright);
+extern int rzsbc_mcu_screen_power_up(void);
+extern int rzsbc_mcu_screen_power_off(void);
+extern void rzsbc_ft5406_start_polling(void);
+extern int rzsbc_mcu_is_connected(void);
+
+int tc358762_dsi_probe(struct mipi_dsi_device *dsi);
+void tc358762_dsi_remove(struct mipi_dsi_device *dsi);
+void tc358762_dsi_shutdown(struct mipi_dsi_device *dsi);
+
+#endif
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index c821fe3ee794..c2bbaf4ad764 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1386,6 +1386,18 @@ config TOUCHSCREEN_ROHM_BU21023
 	  To compile this driver as a module, choose M here: the
 	  module will be called bu21023_ts.
 
+config TOUCHSCREEN_RZSBC_FT5406
+    tristate "Support for RZSBC FT5406 touchscreen"
+    default y
+    depends on I2C
+    help
+      Enable support for the FT5406 touchscreen controller on the RZSBC platform.
+      This driver provides functionality to interface with the FT5406 touchscreen
+      IC.
+
+      The driver communicates with the FT5406 via I2C and supports touchscreen
+      functionality on systems with compatible hardware.
+
 config TOUCHSCREEN_IQS5XX
 	tristate "Azoteq IQS550/572/525 trackpad/touchscreen controller"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index a81cb5aa21a5..c6041657bcb4 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -117,6 +117,7 @@ obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
 obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
+obj-$(CONFIG_TOUCHSCREEN_RZSBC_FT5406)	+= rzsbc_ft5406.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_IQS7211)	+= iqs7211.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
diff --git a/drivers/input/touchscreen/rzsbc_ft5406.c b/drivers/input/touchscreen/rzsbc_ft5406.c
new file mode 100644
index 000000000000..9c7672f38e0c
--- /dev/null
+++ b/drivers/input/touchscreen/rzsbc_ft5406.c
@@ -0,0 +1,387 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * RZ SBC BOARD FT5406 touch driver.
+ *
+ * Copyright (C) 2024 Renesas Electronics Corporation
+ * Copyright (c) 2016 ASUSTek Computer Inc.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include "rzsbc_ft5406.h"
+
+struct rzsbc_ft5406_data *g_ts_data;
+int g_mcu_ready;
+
+static int fts_i2c_read(struct i2c_client *client, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = 0,
+				 .len = writelen,
+				 .buf = writebuf,
+			 },
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int fts_read_reg(struct i2c_client *client, u8 addr, u8 *val)
+{
+	return fts_i2c_read(client, &addr, 1, val, 1);
+}
+
+static int fts_check_fw_ver(struct i2c_client *client)
+{
+	u8 reg_addr, fw_ver[3];
+	int ret;
+
+	reg_addr = FT_REG_FW_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[0], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[1], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_SUB_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[2], 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("Firmware version = %d.%d.%d\n", fw_ver[0], fw_ver[1], fw_ver[2]);
+	return 0;
+
+error:
+	return ret;
+}
+
+static int fts_read_td_status(struct rzsbc_ft5406_data *ts_data)
+{
+	u8 td_status;
+	int ret = -1;
+
+	ret = fts_read_reg(ts_data->client, FT_TD_STATUS_REG, &td_status);
+	if (ret < 0) {
+		LOG_ERR("get reg td_status failed, %d\n", ret);
+		return ret;
+	}
+	return (int)td_status;
+}
+
+static int fts_read_touchdata(struct rzsbc_ft5406_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int ret = -1, i;
+	u8 buf[FT_ONE_TCH_LEN-2] = { 0 };
+	u8 reg_addr, pointid = FT_MAX_ID;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		reg_addr = FT_TOUCH_X_H_REG + (i * FT_ONE_TCH_LEN);
+		ret = fts_i2c_read(ts_data->client, &reg_addr, 1, buf, FT_ONE_TCH_LEN-2);
+		if (ret < 0) {
+			LOG_ERR("read touchdata failed.\n");
+			return ret;
+		}
+
+		pointid = (buf[FT_TOUCH_ID]) >> 4;
+		if (pointid >= MAX_TOUCH_POINTS)
+			break;
+		event->au8_finger_id[i] = pointid;
+		event->au16_x[i] = (s16) (buf[FT_TOUCH_X_H] & 0x0F) << 8 | (s16) buf[FT_TOUCH_X_L];
+		event->au16_y[i] = (s16) (buf[FT_TOUCH_Y_H] & 0x0F) << 8 | (s16) buf[FT_TOUCH_Y_L];
+		event->au8_touch_event[i] = buf[FT_TOUCH_EVENT] >> 6;
+
+		if (ts_data->xy_reverse) {
+			event->au16_x[i] = ts_data->screen_width - event->au16_x[i] - 1;
+			event->au16_y[i] = ts_data->screen_height - event->au16_y[i] - 1;
+		}
+	}
+	event->pressure = FT_PRESS;
+
+	return 0;
+}
+
+static void fts_report_value(struct rzsbc_ft5406_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int i, modified_ids = 0, released_ids;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		if (event->au8_touch_event[i] == FT_TOUCH_DOWN
+				|| event->au8_touch_event[i] == FT_TOUCH_CONTACT) {
+			modified_ids |= 1 << event->au8_finger_id[i];
+			input_mt_slot(ts_data->input_dev, event->au8_finger_id[i]);
+			input_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER,
+				true);
+			input_report_abs(ts_data->input_dev, ABS_MT_TOUCH_MAJOR,
+					event->pressure);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_X,
+					event->au16_x[i]);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_Y,
+					event->au16_y[i]);
+
+			if (!((1 << event->au8_finger_id[i]) & ts_data->known_ids))
+				LOG_DBG("Touch id-%d: x = %d, y = %d\n",
+					event->au8_finger_id[i], event->au16_x[i],
+								 event->au16_y[i]);
+		}
+	}
+
+	released_ids = ts_data->known_ids & ~modified_ids;
+	for (i = 0; released_ids && i < MAX_TOUCH_POINTS; i++) {
+		if (released_ids & (1<<i)) {
+			LOG_DBG("Release id-%d, known = %x modified = %x\n", i, ts_data->known_ids,
+										modified_ids);
+			input_mt_slot(ts_data->input_dev, i);
+			input_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER, false);
+			modified_ids &= ~(1 << i);
+		}
+	}
+	ts_data->known_ids = modified_ids;
+	input_mt_report_pointer_emulation(ts_data->input_dev, true);
+	input_sync(ts_data->input_dev);
+}
+
+extern int rzsbc_mcu_is_connected(void);
+//extern int rzsbc_mcu_ili9881c_is_connected(void); //ili9881c panel is not available
+
+static void fts_retry_clear(struct rzsbc_ft5406_data *ts_data)
+{
+	if (ts_data->retry_count != 0)
+		ts_data->retry_count = 0;
+}
+
+static int fts_retry_wait(struct rzsbc_ft5406_data *ts_data)
+{
+	if (ts_data->retry_count < RETRY_COUNT) {
+		LOG_INFO("wait and retry, count = %d\n", ts_data->retry_count);
+		ts_data->retry_count++;
+		msleep(1000);
+		return 1;
+	}
+	LOG_ERR("attach retry count\n");
+	return 0;
+}
+
+static void rzsbc_ft5406_work(struct work_struct *work)
+{
+	struct ts_event *event = &g_ts_data->event;
+	int ret = 0, count = 5, td_status;
+
+	while (count > 0) {
+		ret = fts_check_fw_ver(g_ts_data->client);
+		if (ret == 0)
+			break;
+		LOG_INFO("checking touch ic, countdown: %d\n", count);
+		msleep(1000);
+		count--;
+	}
+	if (!count) {
+		LOG_ERR("checking touch ic timeout, %d\n", ret);
+		g_ts_data->is_polling = 0;
+		return;
+	}
+
+	//polling 60fps
+	while (1) {
+		td_status = fts_read_td_status(g_ts_data);
+		if (td_status < 0) {
+			ret = fts_retry_wait(g_ts_data);
+			if (ret == 0) {
+				LOG_ERR("stop touch polling\n");
+				g_ts_data->is_polling = 0;
+				break;
+			}
+		} else if (td_status < VALID_TD_STATUS_VAL+1 &&
+			  (td_status > 0 || g_ts_data->known_ids != 0)) {
+			fts_retry_clear(g_ts_data);
+			memset(event, -1, sizeof(struct ts_event));
+			event->touch_point = td_status;
+			ret = fts_read_touchdata(g_ts_data);
+			if (ret == 0)
+				fts_report_value(g_ts_data);
+		}
+		msleep_interruptible(17);
+	}
+}
+
+void rzsbc_ft5406_start_polling(void)
+{
+	if (g_ts_data == NULL) {
+		LOG_ERR("touch is not ready\n");
+	} else if (g_ts_data->is_polling == 1) {
+		LOG_ERR("touch is busy\n");
+	} else {
+		g_ts_data->is_polling = 1;
+		schedule_work(&g_ts_data->ft5406_work);
+	}
+	g_mcu_ready = 1;
+}
+EXPORT_SYMBOL_GPL(rzsbc_ft5406_start_polling);
+
+static int rzsbc_ft5406_probe(struct i2c_client *client)
+{
+	struct input_dev *input_dev;
+	int ret = 0, timeout = 10;
+
+	LOG_INFO("address = 0x%x\n", client->addr);
+
+	g_ts_data = kzalloc(sizeof(struct rzsbc_ft5406_data), GFP_KERNEL);
+	if (g_ts_data == NULL) {
+		LOG_ERR("no memory for device\n");
+		return -ENOMEM;
+	}
+
+	g_ts_data->client = client;
+	i2c_set_clientdata(client, g_ts_data);
+
+	//while(!rzsbc_mcu_is_connected() && !rzsbc_mcu_ili9881c_is_connected() && timeout > 0) {
+	while (!rzsbc_mcu_is_connected() && timeout > 0) {
+		msleep(50);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		LOG_ERR("wait connected timeout\n");
+		ret = -ENODEV;
+		goto timeout_failed;
+	}
+
+#if (0)
+	if (rzsbc_mcu_ili9881c_is_connected()) {
+		g_ts_data->screen_width = 720;
+		g_ts_data->screen_height = 1280;
+		g_ts_data->xy_reverse = 0;
+	} else {
+		g_ts_data->screen_width = 800;
+		g_ts_data->screen_height = 480;
+		g_ts_data->xy_reverse = 1;
+	}
+#endif
+	g_ts_data->screen_width = 800;
+	g_ts_data->screen_height = 480;
+	g_ts_data->xy_reverse = 1;
+
+	LOG_INFO("width = %d, height = %d, reverse = %d\n",
+			g_ts_data->screen_width, g_ts_data->screen_height, g_ts_data->xy_reverse);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		LOG_ERR("failed to allocate input device\n");
+		goto input_allocate_failed;
+	}
+	input_dev->name = "fts_ts";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &g_ts_data->client->dev;
+
+	g_ts_data->input_dev = input_dev;
+	input_set_drvdata(input_dev, g_ts_data);
+
+	__set_bit(EV_SYN, input_dev->evbit);
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(EV_ABS, input_dev->evbit);
+	__set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_mt_init_slots(input_dev, MAX_TOUCH_POINTS, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, g_ts_data->screen_width, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, g_ts_data->screen_height, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		LOG_ERR("Input device registration failed\n");
+		goto input_register_failed;
+	}
+
+	INIT_WORK(&g_ts_data->ft5406_work, rzsbc_ft5406_work);
+	if (g_mcu_ready == 1)
+		schedule_work(&g_ts_data->ft5406_work);
+
+	return 0;
+
+input_register_failed:
+	input_free_device(input_dev);
+input_allocate_failed:
+timeout_failed:
+	kfree(g_ts_data);
+	g_ts_data = NULL;
+	return ret;
+}
+
+static void rzsbc_ft5406_remove(struct i2c_client *client)
+{
+	cancel_work_sync(&g_ts_data->ft5406_work);
+	if (g_ts_data->input_dev) {
+		input_unregister_device(g_ts_data->input_dev);
+		input_free_device(g_ts_data->input_dev);
+	}
+	kfree(g_ts_data);
+	g_ts_data = NULL;
+	g_mcu_ready = 0;
+}
+
+static const struct i2c_device_id rzsbc_ft5406_id[] = {
+	{"rzsbc_ft5406", 0},
+	{/* sentinel */},
+};
+
+static struct i2c_driver rzsbc_ft5406_driver = {
+	.driver = {
+		.name = "rzsbc_ft5406",
+	},
+	.probe = rzsbc_ft5406_probe,
+	.remove = rzsbc_ft5406_remove,
+	.id_table = rzsbc_ft5406_id,
+};
+module_i2c_driver(rzsbc_ft5406_driver);
+
+MODULE_DESCRIPTION("RZG2L SBC BOARD FT5406 Touch driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/rzsbc_ft5406.h b/drivers/input/touchscreen/rzsbc_ft5406.h
new file mode 100644
index 000000000000..03fcefdd1536
--- /dev/null
+++ b/drivers/input/touchscreen/rzsbc_ft5406.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RZSBC_FT5406_H_
+#define _RZSBC_FT5406_H_
+
+#define LOG_DBG(fmt, arg...) pr_debug("rzsbc-ft5406: %s: "fmt, __func__, ##arg)
+#define LOG_INFO(fmt, arg...) pr_info("rzsbc-ft5406: %s: "fmt, __func__, ##arg)
+#define LOG_ERR(fmt, arg...) pr_err("rzsbc-ft5406: %s: "fmt, __func__, ##arg)
+
+#define RETRY_COUNT		10
+#define FT_ONE_TCH_LEN	6
+
+#define FT_REG_FW_VER			0xA6
+#define FT_REG_FW_MIN_VER		0xB2
+#define FT_REG_FW_SUB_MIN_VER	0xB3
+
+#define VALID_TD_STATUS_VAL		10
+#define MAX_TOUCH_POINTS		1
+
+#define FT_PRESS			0x7F
+#define FT_MAX_ID			0x0F
+
+#define FT_TOUCH_X_H	0
+#define FT_TOUCH_X_L	1
+#define FT_TOUCH_Y_H	2
+#define FT_TOUCH_Y_L	3
+#define FT_TOUCH_EVENT	0
+#define FT_TOUCH_ID		2
+
+#define FT_TOUCH_X_H_REG	3
+#define FT_TOUCH_X_L_REG	4
+#define FT_TOUCH_Y_H_REG	5
+#define FT_TOUCH_Y_L_REG	6
+#define FT_TD_STATUS_REG	2
+#define FT_TOUCH_EVENT_REG	3
+#define FT_TOUCH_ID_REG		5
+
+#define FT_TOUCH_DOWN		0
+#define FT_TOUCH_CONTACT	2
+
+struct ts_event {
+	u16 au16_x[MAX_TOUCH_POINTS]; /*x coordinate */
+	u16 au16_y[MAX_TOUCH_POINTS]; /*y coordinate */
+	u8 au8_touch_event[MAX_TOUCH_POINTS]; /*touch event: 0:down; 1:up; 2:contact */
+	u8 au8_finger_id[MAX_TOUCH_POINTS]; /*touch ID */
+	u16 pressure;
+	u8 touch_point;
+	u8 point_num;
+};
+
+struct rzsbc_ft5406_data {
+	struct device *dev;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event event;
+	struct work_struct ft5406_work;
+
+	int screen_width;
+	int screen_height;
+	int xy_reverse;
+	int is_polling;
+	int known_ids;
+	int retry_count;
+};
+
+#endif
+
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index faf983680040..4c7304520c23 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -585,6 +585,22 @@ config NSM
 	  To compile this driver as a module, choose M here.
 	  The module will be called nsm.
 
+config RZSBC_MCU
+    tristate "Support for RZSBC MCU"
+    default y
+    depends on I2C
+    help
+      Enable support for the RZSBC MCU (Microcontroller Unit) responsible for
+      controlling the touchscreen power on the RZSBC platform. This driver
+      manages the power state of the touchscreen, enabling and disabling the
+      touchscreen as needed.
+
+      The MCU communicates with the touchscreen IC via I2C, and this driver
+      is essential for managing touchscreen power and ensuring the display
+      operates correctly. By default, this option is enabled to ensure that
+      the touchscreen power management is active on supported systems.
+
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 153a3f4837e8..66b3c62b609d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -59,6 +59,7 @@ obj-$(CONFIG_PVPANIC)   	+= pvpanic/
 obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
+obj-$(CONFIG_RZSBC_MCU)        	+= rzsbc_mcu.o
 obj-$(CONFIG_NTSYNC)		+= ntsync.o
 obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
 obj-$(CONFIG_OPEN_DICE)		+= open-dice.o
diff --git a/drivers/misc/rzsbc_mcu.c b/drivers/misc/rzsbc_mcu.c
new file mode 100644
index 000000000000..d0649e9c37e3
--- /dev/null
+++ b/drivers/misc/rzsbc_mcu.c
@@ -0,0 +1,356 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *
+ * RZ SBC Board Touchscreen MCU Driver.
+ *
+ * Copyright (C) 2024 Renesas Electronics Corporation
+ * Copyright (c) 2016 ASUSTek Computer Inc.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/backlight.h>
+#include "rzsbc_mcu.h"
+#include <linux/fb.h>
+
+#define BL_DEBUG 0
+static struct rzsbc_mcu_data *g_mcu_data;
+static int connected;
+static int lcd_bright_level;
+static struct backlight_device *bl;
+
+#define MAX_BRIGHENESS		(255)
+
+static int is_hex(char num)
+{
+	//0-9, a-f, A-F
+	if ((num > 47 && num < 58) || (num > 64 && num < 71) || (num > 96 && num < 103))
+		return 1;
+	return 0;
+}
+
+static int string_to_byte(const char *source, unsigned char *destination, int size)
+{
+	int i = 0, counter = 0;
+	unsigned char tmp;
+	int ret;
+
+	if (size % 2 == 1)
+		return -EINVAL;
+
+	for (i = 0; i < size; i += 2) {
+		if (!is_hex(source[i]) || !is_hex(source[i + 1]))
+			return -EINVAL;
+
+		ret = kstrtou8(&source[i], 16, &tmp);
+		if (ret < 0)
+			return -EINVAL;
+
+		destination[counter] = tmp;
+		counter++;
+	}
+	return 0;
+}
+
+static int send_cmds(struct i2c_client *client, const char *buf)
+{
+	int ret, size = strlen(buf), retry = 5;
+	unsigned char byte_cmd[size/2];
+
+	if ((size%2) != 0) {
+		LOG_ERR("size should be even\n");
+		return -EINVAL;
+	}
+
+	LOG_INFO("%s\n", buf);
+
+	string_to_byte(buf, byte_cmd, size);
+
+	while (retry-- > 0) {
+		ret = i2c_master_send(client, byte_cmd, size/2);
+		if (ret <= 0)
+			LOG_ERR("send command failed, ret = %d, retry again!\n", ret);
+		else
+			break;
+	}
+
+	if (ret <= 0) {
+		LOG_ERR("send command failed\n");
+		return ret != 0 ? ret : -ECOMM;
+	}
+
+	msleep(20);
+	return 0;
+}
+
+static int recv_cmds(struct i2c_client *client, char *buf, int size)
+{
+	int ret;
+
+	ret = i2c_master_recv(client, buf, size);
+	if (ret <= 0) {
+		LOG_ERR("receive commands failed, %d\n", ret);
+		return ret != 0 ? ret : -ECOMM;
+	}
+	msleep(20);
+	return 0;
+}
+
+static int init_cmd_check(struct rzsbc_mcu_data *mcu_data)
+{
+	int ret;
+	char recv_buf[1] = {0};
+
+	ret = send_cmds(mcu_data->client, "80");
+	if (ret < 0)
+		goto error;
+
+	recv_cmds(mcu_data->client, recv_buf, 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("recv_cmds: 0x%X\n", recv_buf[0]);
+	if (recv_buf[0] != 0xDE && recv_buf[0] != 0xC3) {
+		LOG_ERR("read wrong info\n");
+		ret = -EINVAL;
+		goto error;
+
+	}
+	return 0;
+
+error:
+	return ret;
+}
+
+int rzsbc_mcu_screen_power_off(void)
+{
+	if (!connected)
+		return -ENODEV;
+
+	LOG_INFO("\n");
+	send_cmds(g_mcu_data->client, "8500");
+	usleep_range(10000, 10001);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rzsbc_mcu_screen_power_off);
+
+int rzsbc_mcu_screen_power_up(void)
+{
+	if (!connected)
+		return -ENODEV;
+
+	LOG_INFO("\n");
+	//send_cmds(g_mcu_data->client, "8500");
+	//msleep(800);
+	send_cmds(g_mcu_data->client, "8501");
+	send_cmds(g_mcu_data->client, "8104");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rzsbc_mcu_screen_power_up);
+
+int rzsbc_mcu_set_bright(int bright)
+{
+	unsigned char cmd[2];
+	int ret;
+
+	if (!connected)
+		return -ENODEV;
+
+	if (bright > 0xff || bright < 0)
+		return -EINVAL;
+
+	if (BL_DEBUG)
+		LOG_INFO("set bright = 0x%x\n", bright);
+
+	cmd[0] = 0x86;
+	cmd[1] = bright;
+
+	ret = i2c_master_send(g_mcu_data->client, cmd, 2);
+	if (ret <= 0) {
+		LOG_ERR("send command failed, ret = %d\n", ret);
+		return ret != 0 ? ret : -ECOMM;
+	}
+
+	lcd_bright_level = bright;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rzsbc_mcu_set_bright);
+
+int rzsbc_mcu_get_brightness(void)
+{
+	return lcd_bright_level;
+}
+EXPORT_SYMBOL_GPL(rzsbc_mcu_get_brightness);
+
+static int rzsbc_mcu_bl_get_brightness(struct backlight_device *bd)
+{
+	return lcd_bright_level;
+}
+
+int rzsbc_mcu_bl_update_status(struct backlight_device *bd)
+{
+	int brightness = bd->props.brightness;
+
+	if (brightness > MAX_BRIGHENESS)
+		brightness = MAX_BRIGHENESS;
+
+	if (brightness <= 0)
+		brightness = 1;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		brightness = 0;
+
+	if (bd->props.state & BL_CORE_SUSPENDED)
+		brightness = 0;
+
+	LOG_INFO("%s  brightness=%d power=%d state =%d bd->props.brightness=%d\n",
+					__func__, brightness, bd->props.power,
+					bd->props.state,
+					bd->props.brightness);
+	return rzsbc_mcu_set_bright(brightness);
+}
+
+static const struct backlight_ops rzsbc_mcu_bl_ops = {
+	.get_brightness	= rzsbc_mcu_bl_get_brightness, //actual_brightness_show
+	.update_status	= rzsbc_mcu_bl_update_status,
+	.options	= BL_CORE_SUSPENDRESUME,
+};
+
+struct backlight_device *rzsbc_mcu_get_backlightdev(void)
+{
+	if (!connected) {
+		LOG_INFO("not ready\n");
+		return NULL;
+	}
+	return bl;
+}
+EXPORT_SYMBOL_GPL(rzsbc_mcu_get_backlightdev);
+
+static ssize_t rzsbc_mcu_bl_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (BL_DEBUG)
+		LOG_INFO("get bright = 0x%x\n", lcd_bright_level);
+
+	return sprintf(buf, "%d\n", lcd_bright_level);
+}
+
+static ssize_t rzsbc_mcu_bl_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	unsigned long value;
+
+	ret = kstrtoul(buf, 0, &value);
+
+	if ((value > MAX_BRIGHENESS) || (ret < 0))
+		LOG_ERR("Invalid value for backlight setting, value = %lu\n", value);
+	else
+		rzsbc_mcu_set_bright(value);
+
+	return strnlen(buf, count);
+}
+static DEVICE_ATTR_RW(rzsbc_mcu_bl);
+
+int rzsbc_mcu_is_connected(void)
+{
+	return connected;
+}
+EXPORT_SYMBOL_GPL(rzsbc_mcu_is_connected);
+
+static int rzsbc_mcu_probe(struct i2c_client *client)
+{
+	struct rzsbc_mcu_data *mcu_data;
+	int ret;
+	struct backlight_properties props;
+
+	LOG_INFO("address = 0x%x\n", client->addr);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LOG_ERR("I2C check functionality failed\n");
+		return -ENODEV;
+	}
+
+	mcu_data = kzalloc(sizeof(struct rzsbc_mcu_data), GFP_KERNEL);
+	if (mcu_data == NULL) {
+		LOG_ERR("no memory for device\n");
+		return -ENOMEM;
+	}
+
+	mcu_data->client = client;
+	i2c_set_clientdata(client, mcu_data);
+	g_mcu_data = mcu_data;
+
+	ret = init_cmd_check(mcu_data);
+	if (ret < 0) {
+		LOG_ERR("init_cmd_check failed, %d\n", ret);
+		goto error;
+	}
+	connected = 1;
+
+	memset(&props, 0, sizeof(props));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = MAX_BRIGHENESS;
+
+	bl = backlight_device_register("panel_backlight", NULL, NULL,
+					&rzsbc_mcu_bl_ops, &props);
+	if (IS_ERR(bl))
+		pr_err("unable to register backlight device\n");
+
+	ret = device_create_file(&client->dev, &dev_attr_rzsbc_mcu_bl);
+	if (ret != 0) {
+		dev_err(&client->dev, "Failed to create rzsbc_mcu_bl sysfs files %d\n", ret);
+		return ret;
+	}
+
+	rzsbc_mcu_screen_power_off();
+
+	return 0;
+
+error:
+	kfree(mcu_data);
+	return ret;
+}
+
+static void rzsbc_mcu_remove(struct i2c_client *client)
+{
+	struct rzsbc_mcu_data *mcu_data = i2c_get_clientdata(client);
+
+	connected = 0;
+	kfree(mcu_data);
+}
+
+static const struct i2c_device_id rzsbc_mcu_id[] = {
+	{"rzsbc_mcu", 0},
+	{/* sentinel */},
+};
+
+static struct i2c_driver rzsbc_mcu_driver = {
+	.driver = {
+		.name = "rzsbc_mcu",
+	},
+	.probe = rzsbc_mcu_probe,
+	.remove = rzsbc_mcu_remove,
+	.id_table = rzsbc_mcu_id,
+};
+module_i2c_driver(rzsbc_mcu_driver);
+
+MODULE_DESCRIPTION("Tinker Board TouchScreen MCU driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/rzsbc_mcu.h b/drivers/misc/rzsbc_mcu.h
new file mode 100644
index 000000000000..1374a39f073b
--- /dev/null
+++ b/drivers/misc/rzsbc_mcu.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RZSBC_MCU_H_
+#define _RZSBC_MCU_H_
+
+#define LOG_INFO(fmt, arg...) pr_info("rzsbc-mcu: %s: "fmt, __func__, ##arg)
+#define LOG_ERR(fmt, arg...) pr_err("rzsbc-mcu: %s: "fmt, __func__, ##arg)
+
+#define MAX_I2C_LEN 255
+
+struct rzsbc_mcu_data {
+	struct device *dev;
+	struct i2c_client *client;
+};
+
+struct backlight_device *rzsbc_mcu_get_backlightdev(void);
+
+int rzsbc_mcu_screen_power_off(void);
+int rzsbc_mcu_screen_power_up(void);
+int rzsbc_mcu_set_bright(int bright);
+int rzsbc_mcu_get_brightness(void);
+int rzsbc_mcu_bl_update_status(struct backlight_device *bd);
+int rzsbc_mcu_is_connected(void);
+
+#endif
-- 
2.43.0

